import pandas as pd
import numpy as np

def load_data(file_name):
    """
    Loads the CSV file into a DataFrame, sorts it by date, and resets the index.
    """
    df = pd.read_csv(file_name, parse_dates=['Date'])
    df.sort_values('Date', inplace=True)
    df.reset_index(drop=True, inplace=True)
    return df

def calculate_rolling_average_drop(df, window=21):
    """
    1. מגדיר 'יום אדום' אם Close < Open.
    2. מחשב daily_drop = (Open - Close) עבור יום אדום, ואפס ליום ירוק.
    3. מחשב ממוצע נע של daily_drop ל-21 ימים אחרונים (ברירת מחדל) על מנת לקבל rolling_avg_drop.
    """
    df['IsRedDay'] = df['Close'] < df['Open']
    df['DailyDrop'] = np.where(df['IsRedDay'], df['Open'] - df['Close'], 0.0)
    
    # rolling mean של 21 ימים, עם shift(1) כדי שהיום הנוכחי לא ייכנס לממוצע של עצמו
    df['RollingAvgDrop'] = df['DailyDrop'].rolling(window=window).mean().shift(1)
    
    # ייתכנו NaN בתחילת הסדרה בגלל rolling ו-shift. נטפל בהם (נניח שאין אסטרטגיה בימים הללו).
    df['RollingAvgDrop'].fillna(0.0, inplace=True)
    return df

def calculate_profit_loss_long(entry_price, exit_price, position_size):
    """
    מחשב רווח/הפסד עבור פוזיציית לונג: (exit_price - entry_price) * number_of_shares
    כאשר number_of_shares = position_size / entry_price.
    """
    if entry_price <= 0:
        return 0  # להימנע מחלוקה ב-0 או ערכי הזנה שגויים
    
    shares = position_size / entry_price
    return shares * (exit_price - entry_price)

def analyze_red_days_strategy(df, initial_investment=16000, rolling_window=21):
    """
    מממש את האסטרטגיה:
    1. מחשב ממוצע נע (rolling) של הירידות בימים אדומים (DailyDrop) ב-rolling_window ימים אחורה.
    2. אם ביום הנוכחי המחיר יורד עד 'Open - RollingAvgDrop', נכנס ל-Long שם.
    3. סגירה ב-Close של אותו יום.
    4. מחשב רווח/הפסד ושומר בטבלה.
    """
    df = df.copy()
    df = calculate_rolling_average_drop(df, window=rolling_window)
    
    trades = []
    
    for i in range(len(df)):
        if i == 0:
            continue  # אין יום קודם, ממשיכים הלאה
        
        current_day = df.iloc[i]
        
        # נבדוק אם בכלל יש לנו ממוצע ירידות הגיוני
        avg_drop = current_day['RollingAvgDrop']
        if avg_drop <= 0:
            continue
        
        open_price = current_day['Open']
        low_price = current_day['Low']
        close_price = current_day['Close']
        
        # המחיר שאליו אנחנו מצפים שירד כדי להיכנס ל-Long
        desired_entry = open_price - avg_drop
        
        # בודקים האם באמת הגענו למחיר הזה במהלך היום (low_price <= desired_entry)
        if low_price <= desired_entry:
            # נכנסים ל-Long במחיר desired_entry
            entry_price = desired_entry
            exit_price = close_price
            profit_loss = calculate_profit_loss_long(entry_price, exit_price, initial_investment)
            
            trades.append({
                'Date': current_day['Date'],
                'Entry Price': entry_price,
                'Exit Price': exit_price,
                'Daily Open': open_price,
                'Daily Low': low_price,
                'Daily Close': close_price,
                'Rolling Avg Drop': avg_drop,
                'Profit/Loss': profit_loss
            })
    
    trades_df = pd.DataFrame(trades)
    return trades_df

def calculate_statistics(trades_df):
    """
    מחשב ומדפיס סטטיסטיקות על הטריידים:
    - כמות טריידים
    - אחוזי הצלחה (Success Rate)
    - ממוצע רווח
    - ממוצע הפסד
    - רווח/הפסד מקסימלי (תאריך)
    """
    if trades_df.empty:
        print("No trades were generated by this strategy.")
        return
    
    total_trades = len(trades_df)
    profits = trades_df['Profit/Loss']
    
    # נבדיל בין רווחים להפסדים
    winning = trades_df[profits > 0]
    losing = trades_df[profits < 0]
    
    success_rate = len(winning) / total_trades if total_trades > 0 else 0
    average_gain = winning['Profit/Loss'].mean() if not winning.empty else 0
    average_loss = losing['Profit/Loss'].mean() if not losing.empty else 0
    max_gain = winning['Profit/Loss'].max() if not winning.empty else 0
    max_loss = losing['Profit/Loss'].min() if not losing.empty else 0
    
    # שולפים תאריכים
    if not winning.empty:
        max_gain_date = winning.loc[winning['Profit/Loss'].idxmax(), 'Date']
    else:
        max_gain_date = None
    
    if not losing.empty:
        max_loss_date = losing.loc[losing['Profit/Loss'].idxmin(), 'Date']
    else:
        max_loss_date = None
    
    print("=== Strategy Statistics ===")
    print(f"Total Trades: {total_trades}")
    print(f"Success Rate: {success_rate:.2%}")
    print(f"Average Gain per Winning Trade: ${average_gain:,.2f}")
    print(f"Average Loss per Losing Trade: ${average_loss:,.2f}")
    if max_gain_date is not None:
        print(f"Max Gain: ${max_gain:,.2f} on {max_gain_date.date()}")
    else:
        print("No winning trades.")
    
    if max_loss_date is not None:
        print(f"Max Loss: ${max_loss:,.2f} on {max_loss_date.date()}")
    else:
        print("No losing trades.")

def simulate_trading(trades_df, initial_investment):
    """
    מדמה מסחר רציף ע"פ סדר התאריכים בטבלה:
    - נכנס לטרייד רק אם הוא קיים באותו יום.
    - בכל טרייד משתמשים בסך ההון הנוכחי כ-Gross Position Size.
    - מעדכנים את ההון הנוכחי בסוף יום.
    
    * שים לב שבאסטרטגיה הזו אנחנו מניחים טרייד יומי (פותחים וסוגרים בו ביום),
      אז אין חפיפה של טריידים על ימים עוקבים (כל יום עומד בפני עצמו).
    """
    if trades_df.empty:
        print("No trades to simulate.")
        return initial_investment
    
    trades_df = trades_df.sort_values('Date').reset_index(drop=True)
    current_balance = initial_investment
    
    for idx, row in trades_df.iterrows():
        # נניח שאנחנו סוחרים בכל טרייד עם כל הסכום העדכני
        entry_price = row['Entry Price']
        exit_price = row['Exit Price']
        
        # מחשבים רווח/הפסד (באופן דומה ל-calculate_profit_loss_long אבל עם current_balance)
        if entry_price <= 0:
            continue
        shares = current_balance / entry_price
        profit_loss = shares * (exit_price - entry_price)
        
        current_balance += profit_loss
    
    print("\n=== Trading Simulation ===")
    print(f"Initial Investment: ${initial_investment:,.2f}")
    print(f"Final Balance after all trades: ${current_balance:,.2f}")
    print(f"Total Profit/Loss: ${(current_balance - initial_investment):,.2f}")
    
    return current_balance

def analyze_spy_red_days(file_name, initial_investment=16000, rolling_window=21):
    """
    פונקציה מרכזית:
    1. טוענת את הדאטה.
    2. מריצה את אסטרטגיית "ממוצע ירידות ימים אדומים".
    3. מציגה סטטיסטיקות.
    4. מדמה מסחר ומדפיסה תוצאות סופיות.
    """
    # 1. טוענים נתונים
    df = load_data(file_name)
    
    # 2. מיישמים את האסטרטגיה
    trades_df = analyze_red_days_strategy(df, initial_investment, rolling_window)
    
    # 3. מחשבים סטטיסטיקות ומדפיסים
    #    (ניצור עמודת Profit/Loss אם היא לא קיימת, אבל יש לנו כבר בעמודת Profit/Loss)
    calculate_statistics(trades_df)
    
    # 4. מדמים מסחר רציף ומדפיסים
    final_balance = simulate_trading(trades_df, initial_investment)
    
    # 5. הדפסת טבלת טריידים (אופציונלי)
    print("\n=== Trades DataFrame ===")
    if not trades_df.empty:
        print(trades_df.to_string(index=False))
    else:
        print("No trades to show.")
    
    return trades_df, final_balance

# דוגמה לשימוש (ניתן להחליף בשם הקובץ המתאים):
if __name__ == "__main__":
    file_name = "D6CK32X6.csv"  # קובץ היסטוריית SPY לדוגמה
    initial_investment = 16000
    trades, final_amount = analyze_spy_red_days(file_name, initial_investment, rolling_window=21)
